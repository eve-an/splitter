// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: features.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteFeature = `-- name: DeleteFeature :exec
DELETE FROM features WHERE id = $1
`

func (q *Queries) DeleteFeature(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFeature, id)
	return err
}

const deleteVariantsByFeature = `-- name: DeleteVariantsByFeature :exec
DELETE FROM variants WHERE feature_id = $1
`

func (q *Queries) DeleteVariantsByFeature(ctx context.Context, featureID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteVariantsByFeature, featureID)
	return err
}

const getFeature = `-- name: GetFeature :many
SELECT
  f.id AS feature_id,
  f.name AS feature_name,
  f.description AS feature_description,
  f.active AS feature_active,
  f.created_at AS feature_created_at,
  v.id AS variant_id,
  v.name AS variant_name,
  v.weight AS variant_weight
FROM features f
LEFT JOIN variants v ON f.id = v.feature_id
WHERE f.id = $1
`

type GetFeatureRow struct {
	FeatureID          int32
	FeatureName        string
	FeatureDescription pgtype.Text
	FeatureActive      bool
	FeatureCreatedAt   pgtype.Timestamptz
	VariantID          pgtype.Int4
	VariantName        pgtype.Text
	VariantWeight      pgtype.Int4
}

func (q *Queries) GetFeature(ctx context.Context, id int32) ([]GetFeatureRow, error) {
	rows, err := q.db.Query(ctx, getFeature, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeatureRow
	for rows.Next() {
		var i GetFeatureRow
		if err := rows.Scan(
			&i.FeatureID,
			&i.FeatureName,
			&i.FeatureDescription,
			&i.FeatureActive,
			&i.FeatureCreatedAt,
			&i.VariantID,
			&i.VariantName,
			&i.VariantWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFeature = `-- name: InsertFeature :one
INSERT INTO features (name, description, active)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertFeatureParams struct {
	Name        string
	Description pgtype.Text
	Active      bool
}

func (q *Queries) InsertFeature(ctx context.Context, arg InsertFeatureParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertFeature, arg.Name, arg.Description, arg.Active)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertVariant = `-- name: InsertVariant :one
INSERT INTO variants (feature_id, name, weight)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertVariantParams struct {
	FeatureID pgtype.Int4
	Name      string
	Weight    int32
}

func (q *Queries) InsertVariant(ctx context.Context, arg InsertVariantParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertVariant, arg.FeatureID, arg.Name, arg.Weight)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listFeatures = `-- name: ListFeatures :many
SELECT
  f.id AS feature_id,
  f.name AS feature_name,
  f.description AS feature_description,
  f.active AS feature_active,
  f.created_at AS feature_created_at,
  v.id AS variant_id,
  v.name AS variant_name,
  v.weight AS variant_weight
FROM features f
LEFT JOIN variants v ON f.id = v.feature_id
ORDER BY f.id
`

type ListFeaturesRow struct {
	FeatureID          int32
	FeatureName        string
	FeatureDescription pgtype.Text
	FeatureActive      bool
	FeatureCreatedAt   pgtype.Timestamptz
	VariantID          pgtype.Int4
	VariantName        pgtype.Text
	VariantWeight      pgtype.Int4
}

func (q *Queries) ListFeatures(ctx context.Context) ([]ListFeaturesRow, error) {
	rows, err := q.db.Query(ctx, listFeatures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturesRow
	for rows.Next() {
		var i ListFeaturesRow
		if err := rows.Scan(
			&i.FeatureID,
			&i.FeatureName,
			&i.FeatureDescription,
			&i.FeatureActive,
			&i.FeatureCreatedAt,
			&i.VariantID,
			&i.VariantName,
			&i.VariantWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeature = `-- name: UpdateFeature :exec
UPDATE features
SET name = $1,
    description = $2,
    active = $3
WHERE id = $4
`

type UpdateFeatureParams struct {
	Name        string
	Description pgtype.Text
	Active      bool
	ID          int32
}

func (q *Queries) UpdateFeature(ctx context.Context, arg UpdateFeatureParams) error {
	_, err := q.db.Exec(ctx, updateFeature,
		arg.Name,
		arg.Description,
		arg.Active,
		arg.ID,
	)
	return err
}
